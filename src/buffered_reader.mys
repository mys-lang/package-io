from .reader import Reader

# Should be part of the bytes class.
def _copy_into_from(dst_data: bytes,
                    dst_start: u64,
                    src_data: bytes,
                    src_start: u64,
                    size: u64):
    for i in range(i64(size)):
        dst_data[i64(dst_start) + i] = src_data[i64(src_start) + i]

class BufferedReader:
    """Efficient reading of any amount of bytes. Small reads are using an
    internal buffer for fewer calls to the underlying reader, while
    big reads are read directly into given destination buffer.

    """

    _reader: Reader
    _buffer: bytes
    _offset: u64
    _size: u64

    def __init__(self, reader: Reader, size: u64 = 64):
        """Create a buffered reader that reads from given reader. Size is the
        size of the internal buffer.

        """

        self._reader = reader
        self._buffer = bytes(size)
        self._offset = 0
        self._size = 0

    def read(self, size: u64) -> bytes:
        """Read given number of bytes. Always returns size number of bytes,
        unless the connection was closed, in which case the remaining
        number of bytes is returned.

        """

        value = bytes(size)
        offset: u64 = 0

        if self._size > 0:
            if size <= self._size:
                _copy_into_from(value, 0, self._buffer, self._offset, size)
                self._offset += size
                self._size -= size

                return value
            else:
                _copy_into_from(value, 0, self._buffer, self._offset, self._size)
                offset = self._size
                self._offset = 0
                self._size = 0

        if size < len(self._buffer):
            read_offset: u64 = 0

            while read_offset < size:
                read = self._reader.try_read_into(self._buffer,
                                                  read_offset,
                                                  len(self._buffer) - read_offset)

                if read == 0:
                    _copy_into_from(value, offset, self._buffer, 0, read_offset)
                    value.resize(i64(offset + read_offset))

                    return value

                read_offset += read

            self._offset = size - offset
            self._size = read_offset - self._offset
            _copy_into_from(value, offset, self._buffer, 0, self._offset)
        else:
            read = self._reader.read_into(value, offset, size - offset)
            value.resize(i64(offset + read))

            if read < size - offset:
                return value

        return value

    def read_until(self, pattern: bytes, keep_pattern: bool = True) -> bytes:
        """Read until given pattern is found. Returns None if the pattern was
        not found before the reader was closed.

        """

        value = b""

        while not value.ends_with(pattern):
            data = self.read(1)

            if len(data) == 0:
                return None

            value += data

        if not keep_pattern:
            value.resize(i64(len(value) - len(pattern)))

        return value

    def read_u8(self) -> u8:
        return self.read(1)[0]

    def read_u16(self) -> u16:
        return (u16(self.read_u8()) << 8) | u16(self.read_u8())

    def read_u32(self) -> u32:
        return (u32(self.read_u16()) << 16) | u32(self.read_u16())

    def read_u64(self) -> u64:
        return (u64(self.read_u32()) << 32) | u64(self.read_u32())

    def read_i8(self) -> i8:
        return i8(self.read_u8())

    def read_i16(self) -> i16:
        return i16(self.read_u16())

    def read_i32(self) -> i32:
        return i32(self.read_u32())

    def read_i64(self) -> i64:
        return i64(self.read_u64())

class _Reader(Reader):
    data: bytes
    _offset: u64

    def _readable(self, size: u64) -> u64:
        left = len(self.data) - self._offset

        if size > left:
            size = left

        return size

    def read(self, size: u64) -> bytes:
        value = b""
        size = self._readable(size)

        for i in range(i64(size)):
            value += self.data[i64(self._offset) + i]

        self._offset += size

        return value

    def read_into(self, data: bytes, start: u64, size: u64) -> u64:
        size = self._readable(size)

        for i in range(i64(size)):
            data[i64(start) + i] = self.read(1)[0]

        return size

    def try_read_into(self, data: bytes, start: u64, size: u64) -> u64:
        return self.read_into(data, start, self._readable(size))

@test
def test_mixed():
    foo = BufferedReader(
        _Reader(
            b"012345678901234567890123456789012345678901234567890123456789"
            b"012345678901234567890123456789"))
    assert foo.read(1) == b"0"
    assert foo.read(2) == b"12"
    assert foo.read_until(b"5") == b"345"
    assert foo.read_until(b"6", keep_pattern=False) == b""
    assert foo.read_until(b"8", keep_pattern=True) == b"78"
    assert foo.read(70) == (
        b"9012345678901234567890123456789012345678901234567890123456789012345678")
    assert foo.read(1) == b"9"
    assert foo.read(70) == b"0123456789"
    assert foo.read(1) == b""

@test
def test_read_unsigned():
    reader = BufferedReader(
        _Reader(
            b"\x12\x34\x56\x78\x9a\xbc\xde\x01\x23\x45\x67\x89\xab\xcd\xef"))
    assert reader.read_u8() == u8(0x12)
    assert reader.read_u16() == u16(0x3456)
    assert reader.read_u32() == u32(0x789abcde)
    assert reader.read_u64() == u64(0x0123456789abcdef)

@test
def test_read_signed():
    reader = BufferedReader(
        _Reader(
            b"\x12\x34\x56\x78\x9a\xbc\xde\x01\x23\x45\x67\x89\xab\xcd\xef"))
    assert reader.read_i8() == i8(0x12)
    assert reader.read_i16() == i16(0x3456)
    assert reader.read_i32() == i32(0x789abcde)
    assert reader.read_i64() == i64(0x0123456789abcdef)

@test
def test_read_until_error():
    foo = BufferedReader(_Reader(b"0123456789"))
    assert foo.read_until(b"g") is None
