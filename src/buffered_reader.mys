from . import Reader

class OutOfDataError(Error):
    pass

class BufferedReader(Reader):
    """Efficient reading of any amount of bytes. Small reads are using an
    internal buffer for fewer calls to the underlying reader, while
    big reads are read directly into given destination buffer.

    """

    _reader: Reader
    _buffer: bytes
    _offset: u64
    _size: u64

    def __init__(self, reader: Reader, size: u64 = 64):
        """Create a buffered reader that reads from given reader. Size is the
        size of the internal buffer.

        """

        self._reader = reader
        self._buffer = bytes(size)
        self._offset = 0
        self._size = 0

    def read(self, size: u64) -> bytes:
        """Read given number of bytes. Always returns size number of bytes,
        unless the connection was closed, in which case the remaining
        number of bytes is returned.

        """

        value = bytes(size)
        offset: u64 = 0

        if self._size > 0:
            if size <= self._size:
                value.copy_into(self._buffer, self._offset, self._offset + size, 0)
                self._offset += size
                self._size -= size

                return value
            else:
                value.copy_into(self._buffer,
                                self._offset,
                                self._offset + self._size,
                                0)
                offset = self._size
                self._offset = 0
                self._size = 0

        left = size - offset

        if left < len(self._buffer):
            read_offset: u64 = 0

            while read_offset < left:
                read = self._reader.try_read_into(self._buffer,
                                                  read_offset,
                                                  len(self._buffer) - read_offset)

                if read == 0:
                    value.copy_into(self._buffer, 0, read_offset, offset)
                    value.resize(i64(offset + read_offset))

                    return value

                read_offset += read

            self._offset = left
            self._size = read_offset - self._offset
            value.copy_into(self._buffer, 0, self._offset, offset)
        else:
            read = self._reader.read_into(value, offset, size - offset)
            value.resize(i64(offset + read))

        return value

    def read_until(self, pattern: bytes, keep_pattern: bool = True) -> bytes:
        """Read until given pattern is found. Returns None if the pattern was
        not found before the reader was closed.

        """

        value = b""

        while not value.ends_with(pattern):
            data = self.read(1)

            if len(data) == 0:
                return None

            value += data

        if not keep_pattern:
            value.resize(i64(len(value) - len(pattern)))

        return value

    def read_u8(self) -> u8:
        """Read an u8. Raises OutOfDataError if the connection was closed.

        """

        data = self.read(1)

        if len(data) == 0:
            raise OutOfDataError()

        return data[0]

    def read_u16(self) -> u16:
        """Read an u16. Raises OutOfDataError if the connection was closed.

        """

        return (u16(self.read_u8()) << 8) | u16(self.read_u8())

    def read_u32(self) -> u32:
        """Read an u32. Raises OutOfDataError if the connection was closed.

        """

        return (u32(self.read_u16()) << 16) | u32(self.read_u16())

    def read_u64(self) -> u64:
        """Read an u64. Raises OutOfDataError if the connection was closed.

        """

        return (u64(self.read_u32()) << 32) | u64(self.read_u32())

    def read_i8(self) -> i8:
        """Read an i8. Raises OutOfDataError if the connection was closed.

        """

        return i8(self.read_u8())

    def read_i16(self) -> i16:
        """Read an i16. Raises OutOfDataError if the connection was closed.

        """

        return i16(self.read_u16())

    def read_i32(self) -> i32:
        """Read an i32. Raises OutOfDataError if the connection was closed.

        """

        return i32(self.read_u32())

    def read_i64(self) -> i64:
        """Read an i64. Raises OutOfDataError if the connection was closed.

        """

        return i64(self.read_u64())

class _Reader(Reader):
    data: bytes
    _offset: u64

    def _readable(self, size: u64) -> u64:
        left = len(self.data) - self._offset

        if size > left:
            size = left

        return size

    def read(self, size: u64) -> bytes:
        value = b""
        size = self._readable(size)

        for i in range(i64(size)):
            value += self.data[i64(self._offset) + i]

        self._offset += size

        return value

    def read_into(self, data: bytes, start: u64, size: u64) -> u64:
        size = self._readable(size)

        for i in range(i64(size)):
            data[i64(start) + i] = self.read(1)[0]

        return size

    def try_read_into(self, data: bytes, start: u64, size: u64) -> u64:
        return self.read_into(data, start, self._readable(size))

@test
def test_mixed():
    foo = BufferedReader(
        _Reader(
            b"012345678901234567890123456789012345678901234567890123456789"
            b"012345678901234567890123456789"))
    assert foo.read(1) == b"0"
    assert foo.read(2) == b"12"
    assert foo.read_until(b"5") == b"345"
    assert foo.read_until(b"6", keep_pattern=False) == b""
    assert foo.read_until(b"8", keep_pattern=True) == b"78"
    assert foo.read(70) == (
        b"9012345678901234567890123456789012345678901234567890123456789012345678")
    assert foo.read(1) == b"9"
    assert foo.read(70) == b"0123456789"
    assert foo.read(1) == b""

@test
def test_read_unsigned():
    reader = BufferedReader(
        _Reader(
            b"\x12\x34\x56\x78\x9a\xbc\xde\x01\x23\x45\x67\x89\xab\xcd\xef"))
    assert reader.read_u8() == u8(0x12)
    assert reader.read_u16() == u16(0x3456)
    assert reader.read_u32() == u32(0x789abcde)
    assert reader.read_u64() == u64(0x0123456789abcdef)

    try:
        reader.read_u8()
        assert False
    except OutOfDataError:
        pass

@test
def test_read_signed():
    reader = BufferedReader(
        _Reader(
            b"\x12\x34\x56\x78\x9a\xbc\xde\x01\x23\x45\x67\x89\xab\xcd\xef"))
    assert reader.read_i8() == i8(0x12)
    assert reader.read_i16() == i16(0x3456)
    assert reader.read_i32() == i32(0x789abcde)
    assert reader.read_i64() == i64(0x0123456789abcdef)

    try:
        reader.read_i8()
        assert False
    except OutOfDataError:
        pass

@test
def test_read_until_error():
    foo = BufferedReader(_Reader(b"0123456789"))
    assert foo.read_until(b"g") is None

@test
def test_read_into():
    reader = BufferedReader(
        _Reader(
            b"\x12\x34\x56\x78\x9a\xbc\xde\x01\x23\x45\x67\x89\xab\xcd\xef"))
    data = b"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    assert reader.read_into(data, 0, 1) == 1
    assert data == b"\x12\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    assert reader.read_into(data, 1, 3) == 3
    assert data == b"\x12\x34\x56\x78\x00\x00\x00\x00\x00\x00"
    assert reader.read_into(data, 3, 2) == 2
    assert data == b"\x12\x34\x56\x9a\xbc\x00\x00\x00\x00\x00"
    assert reader.try_read_into(data, 9, 1) == 1
    assert data == b"\x12\x34\x56\x9a\xbc\x00\x00\x00\x00\xde"
    assert reader.read_into(data, 1, 10) == 8
    assert data == b"\x12\x01\x23\x45\x67\x89\xab\xcd\xef\xde"
